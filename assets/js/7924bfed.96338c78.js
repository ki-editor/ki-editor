"use strict";(globalThis.webpackChunkdocu=globalThis.webpackChunkdocu||[]).push([[2946],{54306(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"evoluation-of-delete","metadata":{"permalink":"/ki-editor/blog/evoluation-of-delete","editUrl":"https://github.com/ki-editor/ki-editor/tree/master/blog/2026-01-10-evolution-of-delete.md","source":"@site/blog/2026-01-10-evolution-of-delete.md","title":"Evolution of Delete","description":"In this article, I\'ll discuss how the Delete operation went through several revisions before arriving at its current behavior.","date":"2026-01-10T00:00:00.000Z","tags":[{"inline":true,"label":"documentation","permalink":"/ki-editor/blog/tags/documentation"}],"readingTime":7.095,"hasTruncateMarker":false,"authors":[{"name":"Jia Hau","title":"Ki maintainer","url":"https://github.com/wongjiahau","socials":{},"key":null,"page":null}],"frontMatter":{"slug":"evoluation-of-delete","title":"Evolution of Delete","authors":[{"name":"Jia Hau","title":"Ki maintainer","url":"https://github.com/wongjiahau"}],"tags":["documentation"]},"unlisted":false,"nextItem":{"title":"Documentation Migration","permalink":"/ki-editor/blog/documentation-migration"}},"content":"In this article, I\'ll discuss how the Delete operation went through several revisions before arriving at its current behavior.\\n\\n## Version 1: Selection mode-specific\\n\\nIn the initial version, Delete already worked quite differently from how it works in other modal editors like Vim/Kakoune.\\n\\nIn Vim/Kakoune, once a selection is deleted, the new selection collapses into a single-character selection.\\n\\nFor example (assuming `[` and `]` represent the boundaries of a selection):\\n\\n```\\nfoo [bar] spam\\n```\\n\\nAfter Delete, the result is:\\n\\n```\\nfoo [ ]spam\\n```\\n\\nBut using Version 1 Delete in Ki, the result is:\\n\\n```\\nfoo [spam]\\n```\\n\\nWhat are the differences?\\n\\n1. `spam` is automatically selected.\\n2. The gap between `bar` and `spam` (a single whitespace ` `) is also deleted.\\n\\nWhy? This allows users to easily delete the next word by executing Delete again.\\n\\nYou might ask: why doesn\'t the editor select `foo` after deleting `bar`, instead of `spam`?\\n\\nThat\'s because the default direction moves forward (rightward) after deleting the current selection.\\n\\nThere was also another action called Delete Backward.\\n\\nSo what was the problem with Version 1?\\n\\nIn Ki, there are two kinds of lateral movements:\\n\\n1. **Left/Right**: skips insignificant selections\\n2. **Previous/Next**: does not skip insignificant selections\\n\\nYou can think of the possible selections of Previous/Next as a superset of those of Left/Right.\\n\\nThis creates a choice: should Delete use Previous/Next or Left/Right to determine which gap to delete?\\n\\nHere\'s where the conflict arises.\\n\\nIn Word selection mode (called Token in this version), which selects common identifiers such as `snake_case`, `kebab-case`, `camelCase`, etc., the insignificant selections are symbols such as `-`, `::`, `/`, etc.\\n\\nIf Delete uses the Left/Right movement in Word selection mode, we\'d have unexpected deletions like this:\\n\\nInitial state:\\n\\n```\\nspam\\n[foo].\\nbar\\n```\\n\\nExecuting Delete would delete the `.` and `\\\\n` as well:\\n\\n```\\nspam\\n[bar]\\n```\\n\\nThis could be desirable or surprising depending on what you intended to achieve.\\n\\nTherefore, the less surprising choice was to use Previous/Next for Delete, which would result in:\\n\\n```\\nspam\\n[.]\\nbar\\n```\\n\\nHowever, using Previous/Next for Delete wasn\'t ideal in Syntax Node selection mode. For example:\\n\\nInitial state:\\n\\n```\\nfn main([x: X], y: Y, z: Z) {}\\n```\\n\\nIf Delete uses Previous/Next, the result would be:\\n\\n```\\nfn main([,] y: Y, z: Z) {}\\n```\\n\\nThis is undesirable because when deleting a sibling node in Syntax Node selection mode, we typically want to delete its trailing insignificant symbol (in this case, `,`) to ensure the code remains syntactically valid after deletion:\\n\\n```\\nfn main([y: Y], z: Z) {}\\n```\\n\\nBecause different selection modes called for different lateral movements, the initial version had to use different lateral movements for different selection modes.\\n\\n## Version 2: Resolving the inconsistencies\\n\\nReference commit: https://github.com/ki-editor/ki-editor/commit/b6747ecb07130aedb8edd53392936d878db55108\\n\\n@vishal noticed that Delete behaved inconsistently across different selection modes, and suggested we make Delete\'s behavior consistent, as consistency is one of Ki\'s design principles.\\n\\nIn this version, we decided that Delete should use the Left/Right movement for all selection modes.\\n\\nThis raised a question: what if you want Delete to use the Previous/Next movement?\\n\\nThat\'s why we introduced a new action called _Delete 0 Gap_, which does exactly that. (This name is actually somewhat misleading because it does delete gaps.)\\n\\nHowever, Delete 0 Gap was bound to the shift layer, making it less ergonomic to use.\\n\\n## Version 3: Delete submode\\n\\nBefore introducing this version, we need to mention https://github.com/ki-editor/ki-editor/commit/2bc355ba22783abe3541a425462c396ac3fb571b, where @vishal used Swap Cursor to reverse the direction of actions such as Delete, Paste, and Open.\\n\\nAfter this change, the Delete Backward action (which used to be a shifted key) was removed.\\n\\nTo delete backward, you simply execute Swap Cursor first.\\n\\nThe introduction of Swap Cursor for reversing actions, combined with Version 2\'s Delete behavior, made certain actions quite unergonomic. For example, to delete backward using the Previous/Next movement, you had to first execute Swap Cursor, then press shift to execute Delete 0 Gap.\\n\\nTo make all kinds of Delete equally ergonomic, in https://github.com/ki-editor/ki-editor/commit/fa09130cf93945c60550849ed76a8e590ceaef93, the Delete action was turned into a submode (similar to the Multi-cursor and Swap submodes).\\n\\nAs a submode, all kinds of delete take the same number of steps\u2014minimally 3:\\n\\n1. Enter Delete Submode\\n2. Execute a Movement\\n3. Escape Delete submode\\n\\n## Version 4: What you see is what you get\\n\\nAlthough making all delete operations equally easy to execute solved one problem, it also meant they were all equally **tiring** to execute.\\n\\n@\\\\_**Vishal|981015** [said](https://ki-editor.zulipchat.com/#narrow/channel/551672-Feature-Idea-.F0.9F.92.A1/topic/Expand.20Selection.20Action/near/564614863):\\n\\n> As currently although Space solves for unergonomic of esc on normal keybaprds, the delete submode\'s Action Motion Motion feels a bit tiring tbh.\\n\\nTo resolve this issue while still allowing gaps to be deleted, this version introduced two new actions: Expand Forward and Expand Backward.\\n\\nExpand Forward expands the current selection rightward until just before the Right selection.\\n\\nFor example, in Word selection mode:\\n\\n```\\nfoo [bar] spam\\n```\\n\\nExecuting Expand Forward results in:\\n\\n```\\nfoo [bar ]spam\\n```\\n\\nExpand Backward works identically but in the opposite direction.\\n\\nWith this change, Delete no longer **automatically deletes gaps**. Now what you select is what gets deleted\u2014no more surprises or unexpected behaviors.\\n\\nIf a gap you intended to delete wasn\'t deleted, it means you didn\'t select it in the first place.\\n\\nThis raises a question: will the following selection still be selected as Version 1 Delete did?\\n\\nYes, but only if the upcoming selection will occupy the same range after deleting the current selection.\\n\\nThis ensures that the cursor position (start of the selection) doesn\'t change after executing Delete.\\n\\nFor example, in Word selection mode:\\n\\n```\\nfoo [bar ]spam\\n```\\n\\nExecuting Delete results in the new selection being `spam`:\\n\\n```\\nfoo [spam]\\n```\\n\\nbecause the position of the first character of `spam` intersects with the cursor position.\\n\\nIn contrast, if the starting state is:\\n\\n```\\nfoo [bar] spam\\n```\\n\\nThen after Delete, only the whitespace following `bar` is selected:\\n\\n```\\nfoo [ ]spam\\n```\\n\\nThis version of Delete reduces the minimal number of steps from 3 to 1.\\n\\nExample:\\n\\n- Delete Forward without deleting Gap: 1 step\\n- Delete Forward including Gap: 2 step (execute Expand Forward first)\\n- Delete Backward without deleting Gap: 2 step (execute Swap Cursor first)\\n- Delete Backward including Gap: 3 Step (execute Expand Backward and Swap Cursor first)\\n\\n## Version 5: Delete Menu\\n\\nThe issues with Version 4 are:\\n\\n1. The gap between the current selection and the adjacent selection is not deleted unless Expand Selection was executed first\\n2. The adjacent selection will not be selected, which breaks the flow\\n\\nVersion 3 (Delete Submode) was already very good in terms of effectiveness\u2014the capability for users to execute what they have in mind accurately.\\n\\nIts only downside was lethargy: a simple deletion that includes a gap takes at least 3 keypresses (`v <movement> space`), where the last key exits the submode.\\n\\nTo make Delete less tiring, we decided to make Delete a **menu** instead of a submode. The key difference is that **a menu automatically closes after selecting one option**, while **a submode stays active until explicitly exited**. This means a simple deletion that includes a gap now takes only 2 keypresses: `v <movement>`.\\n\\nThe tradeoff is that you cannot chain multiple deletions in one invocation. However, this can be compensated with the Extend action (`g`) for multi-selection workflows.\\n\\nFor example, to delete two selections:\\n\\n- **With Delete Submode**: Enter Delete Submode \u2192 Right \u2192 Right \u2192 Escape Delete Submode\\n- **With Extend + Delete Menu**: Extend \u2192 Right \u2192 Open Delete Menu \u2192 Right\\n\\nSince most deletions involve only one selection, the menu approach is more efficient for the common case while keeping the Delete Submode available for users who prefer chaining deletions.\\n\\n## Version 6: Momentary Layer\\n\\n[Momentary Layer](https://zmk.dev/docs/keymaps/behaviors/layers#momentary-layer) combines the best aspects of both the Delete Menu and Delete Submode approaches: it\'s as efficient as the Delete Menu for single deletions while being as repeatable as the Delete Submode for chained operations.\\n\\nHere\'s how it works: when the Delete key (`v` at the time of writing) is **held down**, the Delete submode activates, allowing you to repeatedly press movement keys like Right to delete multiple selections forward. As soon as you release the Delete key, the Delete submode automatically deactivates.\\n\\nWhen **tapped** (pressed and released immediately), it executes the Delete One action directly, making the most common case even more efficient than the Delete Menu, which required two keypresses (i.e. `v v`).\\n\\nThe momentary layer approach eliminates the keypress overhead of explicitly entering and exiting modes, making deletion feel more natural and immediate."},{"id":"documentation-migration","metadata":{"permalink":"/ki-editor/blog/documentation-migration","editUrl":"https://github.com/ki-editor/ki-editor/tree/master/blog/2024-09-20-migrated-to-docusaurus.md","source":"@site/blog/2024-09-20-migrated-to-docusaurus.md","title":"Documentation Migration","description":"Ki\'s documentation has migrated from Rust MD Book to Docusaurus to incorporate interactive tutorials.","date":"2024-09-20T00:00:00.000Z","tags":[{"inline":true,"label":"documentation","permalink":"/ki-editor/blog/tags/documentation"}],"readingTime":0.07,"hasTruncateMarker":false,"authors":[{"name":"Jia Hau","title":"Ki maintainer","url":"https://github.com/wongjiahau","socials":{},"key":null,"page":null}],"frontMatter":{"slug":"documentation-migration","title":"Documentation Migration","authors":[{"name":"Jia Hau","title":"Ki maintainer","url":"https://github.com/wongjiahau"}],"tags":["documentation"]},"unlisted":false,"prevItem":{"title":"Evolution of Delete","permalink":"/ki-editor/blog/evoluation-of-delete"}},"content":"Ki\'s documentation has migrated from Rust MD Book to Docusaurus to incorporate interactive tutorials."}]}}')}}]);