"use strict";(globalThis.webpackChunkdocu=globalThis.webpackChunkdocu||[]).push([[3924],{16338(e){e.exports=JSON.parse('{"permalink":"/ki-editor/blog/evoluation-of-delete","editUrl":"https://github.com/ki-editor/ki-editor/tree/master/blog/2026-01-10-evolution-of-delete.md","source":"@site/blog/2026-01-10-evolution-of-delete.md","title":"Evolution of Delete","description":"In this article, I\'ll discuss how the Delete operation went through several revisions before arriving at its current behavior.","date":"2026-01-10T00:00:00.000Z","tags":[{"inline":true,"label":"documentation","permalink":"/ki-editor/blog/tags/documentation"}],"readingTime":7.095,"hasTruncateMarker":false,"authors":[{"name":"Jia Hau","title":"Ki maintainer","url":"https://github.com/wongjiahau","socials":{},"key":null,"page":null}],"frontMatter":{"slug":"evoluation-of-delete","title":"Evolution of Delete","authors":[{"name":"Jia Hau","title":"Ki maintainer","url":"https://github.com/wongjiahau"}],"tags":["documentation"]},"unlisted":false,"nextItem":{"title":"Documentation Migration","permalink":"/ki-editor/blog/documentation-migration"}}')},28453(e,n,i){i.d(n,{R:()=>l,x:()=>r});var t=i(96540);const s={},o=t.createContext(s);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(o.Provider,{value:n},e.children)}},29564(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});var t=i(16338),s=i(74848),o=i(28453);const l={slug:"evoluation-of-delete",title:"Evolution of Delete",authors:[{name:"Jia Hau",title:"Ki maintainer",url:"https://github.com/wongjiahau"}],tags:["documentation"]},r="Evolution of Delete",a={authorsImageUrls:[void 0]},d=[{value:"Version 1: Selection mode-specific",id:"version-1-selection-mode-specific",level:2},{value:"Version 2: Resolving the inconsistencies",id:"version-2-resolving-the-inconsistencies",level:2},{value:"Version 3: Delete submode",id:"version-3-delete-submode",level:2},{value:"Version 4: What you see is what you get",id:"version-4-what-you-see-is-what-you-get",level:2},{value:"Version 5: Delete Menu",id:"version-5-delete-menu",level:2},{value:"Version 6: Momentary Layer",id:"version-6-momentary-layer",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"In this article, I'll discuss how the Delete operation went through several revisions before arriving at its current behavior."}),"\n",(0,s.jsx)(n.h2,{id:"version-1-selection-mode-specific",children:"Version 1: Selection mode-specific"}),"\n",(0,s.jsx)(n.p,{children:"In the initial version, Delete already worked quite differently from how it works in other modal editors like Vim/Kakoune."}),"\n",(0,s.jsx)(n.p,{children:"In Vim/Kakoune, once a selection is deleted, the new selection collapses into a single-character selection."}),"\n",(0,s.jsxs)(n.p,{children:["For example (assuming ",(0,s.jsx)(n.code,{children:"["})," and ",(0,s.jsx)(n.code,{children:"]"})," represent the boundaries of a selection):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [bar] spam\n"})}),"\n",(0,s.jsx)(n.p,{children:"After Delete, the result is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [ ]spam\n"})}),"\n",(0,s.jsx)(n.p,{children:"But using Version 1 Delete in Ki, the result is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [spam]\n"})}),"\n",(0,s.jsx)(n.p,{children:"What are the differences?"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"spam"})," is automatically selected."]}),"\n",(0,s.jsxs)(n.li,{children:["The gap between ",(0,s.jsx)(n.code,{children:"bar"})," and ",(0,s.jsx)(n.code,{children:"spam"})," (a single whitespace ",(0,s.jsx)(n.code,{children:" "}),") is also deleted."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Why? This allows users to easily delete the next word by executing Delete again."}),"\n",(0,s.jsxs)(n.p,{children:["You might ask: why doesn't the editor select ",(0,s.jsx)(n.code,{children:"foo"})," after deleting ",(0,s.jsx)(n.code,{children:"bar"}),", instead of ",(0,s.jsx)(n.code,{children:"spam"}),"?"]}),"\n",(0,s.jsx)(n.p,{children:"That's because the default direction moves forward (rightward) after deleting the current selection."}),"\n",(0,s.jsx)(n.p,{children:"There was also another action called Delete Backward."}),"\n",(0,s.jsx)(n.p,{children:"So what was the problem with Version 1?"}),"\n",(0,s.jsx)(n.p,{children:"In Ki, there are two kinds of lateral movements:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Left/Right"}),": skips insignificant selections"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Previous/Next"}),": does not skip insignificant selections"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can think of the possible selections of Previous/Next as a superset of those of Left/Right."}),"\n",(0,s.jsx)(n.p,{children:"This creates a choice: should Delete use Previous/Next or Left/Right to determine which gap to delete?"}),"\n",(0,s.jsx)(n.p,{children:"Here's where the conflict arises."}),"\n",(0,s.jsxs)(n.p,{children:["In Word selection mode (called Token in this version), which selects common identifiers such as ",(0,s.jsx)(n.code,{children:"snake_case"}),", ",(0,s.jsx)(n.code,{children:"kebab-case"}),", ",(0,s.jsx)(n.code,{children:"camelCase"}),", etc., the insignificant selections are symbols such as ",(0,s.jsx)(n.code,{children:"-"}),", ",(0,s.jsx)(n.code,{children:"::"}),", ",(0,s.jsx)(n.code,{children:"/"}),", etc."]}),"\n",(0,s.jsx)(n.p,{children:"If Delete uses the Left/Right movement in Word selection mode, we'd have unexpected deletions like this:"}),"\n",(0,s.jsx)(n.p,{children:"Initial state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"spam\n[foo].\nbar\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Executing Delete would delete the ",(0,s.jsx)(n.code,{children:"."})," and ",(0,s.jsx)(n.code,{children:"\\n"})," as well:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"spam\n[bar]\n"})}),"\n",(0,s.jsx)(n.p,{children:"This could be desirable or surprising depending on what you intended to achieve."}),"\n",(0,s.jsx)(n.p,{children:"Therefore, the less surprising choice was to use Previous/Next for Delete, which would result in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"spam\n[.]\nbar\n"})}),"\n",(0,s.jsx)(n.p,{children:"However, using Previous/Next for Delete wasn't ideal in Syntax Node selection mode. For example:"}),"\n",(0,s.jsx)(n.p,{children:"Initial state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn main([x: X], y: Y, z: Z) {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"If Delete uses Previous/Next, the result would be:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn main([,] y: Y, z: Z) {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is undesirable because when deleting a sibling node in Syntax Node selection mode, we typically want to delete its trailing insignificant symbol (in this case, ",(0,s.jsx)(n.code,{children:","}),") to ensure the code remains syntactically valid after deletion:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn main([y: Y], z: Z) {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because different selection modes called for different lateral movements, the initial version had to use different lateral movements for different selection modes."}),"\n",(0,s.jsx)(n.h2,{id:"version-2-resolving-the-inconsistencies",children:"Version 2: Resolving the inconsistencies"}),"\n",(0,s.jsxs)(n.p,{children:["Reference commit: ",(0,s.jsx)(n.a,{href:"https://github.com/ki-editor/ki-editor/commit/b6747ecb07130aedb8edd53392936d878db55108",children:"https://github.com/ki-editor/ki-editor/commit/b6747ecb07130aedb8edd53392936d878db55108"})]}),"\n",(0,s.jsx)(n.p,{children:"@vishal noticed that Delete behaved inconsistently across different selection modes, and suggested we make Delete's behavior consistent, as consistency is one of Ki's design principles."}),"\n",(0,s.jsx)(n.p,{children:"In this version, we decided that Delete should use the Left/Right movement for all selection modes."}),"\n",(0,s.jsx)(n.p,{children:"This raised a question: what if you want Delete to use the Previous/Next movement?"}),"\n",(0,s.jsxs)(n.p,{children:["That's why we introduced a new action called ",(0,s.jsx)(n.em,{children:"Delete 0 Gap"}),", which does exactly that. (This name is actually somewhat misleading because it does delete gaps.)"]}),"\n",(0,s.jsx)(n.p,{children:"However, Delete 0 Gap was bound to the shift layer, making it less ergonomic to use."}),"\n",(0,s.jsx)(n.h2,{id:"version-3-delete-submode",children:"Version 3: Delete submode"}),"\n",(0,s.jsxs)(n.p,{children:["Before introducing this version, we need to mention ",(0,s.jsx)(n.a,{href:"https://github.com/ki-editor/ki-editor/commit/2bc355ba22783abe3541a425462c396ac3fb571b",children:"https://github.com/ki-editor/ki-editor/commit/2bc355ba22783abe3541a425462c396ac3fb571b"}),", where @vishal used Swap Cursor to reverse the direction of actions such as Delete, Paste, and Open."]}),"\n",(0,s.jsx)(n.p,{children:"After this change, the Delete Backward action (which used to be a shifted key) was removed."}),"\n",(0,s.jsx)(n.p,{children:"To delete backward, you simply execute Swap Cursor first."}),"\n",(0,s.jsx)(n.p,{children:"The introduction of Swap Cursor for reversing actions, combined with Version 2's Delete behavior, made certain actions quite unergonomic. For example, to delete backward using the Previous/Next movement, you had to first execute Swap Cursor, then press shift to execute Delete 0 Gap."}),"\n",(0,s.jsxs)(n.p,{children:["To make all kinds of Delete equally ergonomic, in ",(0,s.jsx)(n.a,{href:"https://github.com/ki-editor/ki-editor/commit/fa09130cf93945c60550849ed76a8e590ceaef93",children:"https://github.com/ki-editor/ki-editor/commit/fa09130cf93945c60550849ed76a8e590ceaef93"}),", the Delete action was turned into a submode (similar to the Multi-cursor and Swap submodes)."]}),"\n",(0,s.jsx)(n.p,{children:"As a submode, all kinds of delete take the same number of steps\u2014minimally 3:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Enter Delete Submode"}),"\n",(0,s.jsx)(n.li,{children:"Execute a Movement"}),"\n",(0,s.jsx)(n.li,{children:"Escape Delete submode"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"version-4-what-you-see-is-what-you-get",children:"Version 4: What you see is what you get"}),"\n",(0,s.jsxs)(n.p,{children:["Although making all delete operations equally easy to execute solved one problem, it also meant they were all equally ",(0,s.jsx)(n.strong,{children:"tiring"})," to execute."]}),"\n",(0,s.jsxs)(n.p,{children:["@_",(0,s.jsx)(n.strong,{children:"Vishal|981015"})," ",(0,s.jsx)(n.a,{href:"https://ki-editor.zulipchat.com/#narrow/channel/551672-Feature-Idea-.F0.9F.92.A1/topic/Expand.20Selection.20Action/near/564614863",children:"said"}),":"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"As currently although Space solves for unergonomic of esc on normal keybaprds, the delete submode's Action Motion Motion feels a bit tiring tbh."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To resolve this issue while still allowing gaps to be deleted, this version introduced two new actions: Expand Forward and Expand Backward."}),"\n",(0,s.jsx)(n.p,{children:"Expand Forward expands the current selection rightward until just before the Right selection."}),"\n",(0,s.jsx)(n.p,{children:"For example, in Word selection mode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [bar] spam\n"})}),"\n",(0,s.jsx)(n.p,{children:"Executing Expand Forward results in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [bar ]spam\n"})}),"\n",(0,s.jsx)(n.p,{children:"Expand Backward works identically but in the opposite direction."}),"\n",(0,s.jsxs)(n.p,{children:["With this change, Delete no longer ",(0,s.jsx)(n.strong,{children:"automatically deletes gaps"}),". Now what you select is what gets deleted\u2014no more surprises or unexpected behaviors."]}),"\n",(0,s.jsx)(n.p,{children:"If a gap you intended to delete wasn't deleted, it means you didn't select it in the first place."}),"\n",(0,s.jsx)(n.p,{children:"This raises a question: will the following selection still be selected as Version 1 Delete did?"}),"\n",(0,s.jsx)(n.p,{children:"Yes, but only if the upcoming selection will occupy the same range after deleting the current selection."}),"\n",(0,s.jsx)(n.p,{children:"This ensures that the cursor position (start of the selection) doesn't change after executing Delete."}),"\n",(0,s.jsx)(n.p,{children:"For example, in Word selection mode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [bar ]spam\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Executing Delete results in the new selection being ",(0,s.jsx)(n.code,{children:"spam"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [spam]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["because the position of the first character of ",(0,s.jsx)(n.code,{children:"spam"})," intersects with the cursor position."]}),"\n",(0,s.jsx)(n.p,{children:"In contrast, if the starting state is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [bar] spam\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then after Delete, only the whitespace following ",(0,s.jsx)(n.code,{children:"bar"})," is selected:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"foo [ ]spam\n"})}),"\n",(0,s.jsx)(n.p,{children:"This version of Delete reduces the minimal number of steps from 3 to 1."}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Delete Forward without deleting Gap: 1 step"}),"\n",(0,s.jsx)(n.li,{children:"Delete Forward including Gap: 2 step (execute Expand Forward first)"}),"\n",(0,s.jsx)(n.li,{children:"Delete Backward without deleting Gap: 2 step (execute Swap Cursor first)"}),"\n",(0,s.jsx)(n.li,{children:"Delete Backward including Gap: 3 Step (execute Expand Backward and Swap Cursor first)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"version-5-delete-menu",children:"Version 5: Delete Menu"}),"\n",(0,s.jsx)(n.p,{children:"The issues with Version 4 are:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The gap between the current selection and the adjacent selection is not deleted unless Expand Selection was executed first"}),"\n",(0,s.jsx)(n.li,{children:"The adjacent selection will not be selected, which breaks the flow"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Version 3 (Delete Submode) was already very good in terms of effectiveness\u2014the capability for users to execute what they have in mind accurately."}),"\n",(0,s.jsxs)(n.p,{children:["Its only downside was lethargy: a simple deletion that includes a gap takes at least 3 keypresses (",(0,s.jsx)(n.code,{children:"v <movement> space"}),"), where the last key exits the submode."]}),"\n",(0,s.jsxs)(n.p,{children:["To make Delete less tiring, we decided to make Delete a ",(0,s.jsx)(n.strong,{children:"menu"})," instead of a submode. The key difference is that ",(0,s.jsx)(n.strong,{children:"a menu automatically closes after selecting one option"}),", while ",(0,s.jsx)(n.strong,{children:"a submode stays active until explicitly exited"}),". This means a simple deletion that includes a gap now takes only 2 keypresses: ",(0,s.jsx)(n.code,{children:"v <movement>"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The tradeoff is that you cannot chain multiple deletions in one invocation. However, this can be compensated with the Extend action (",(0,s.jsx)(n.code,{children:"g"}),") for multi-selection workflows."]}),"\n",(0,s.jsx)(n.p,{children:"For example, to delete two selections:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"With Delete Submode"}),": Enter Delete Submode \u2192 Right \u2192 Right \u2192 Escape Delete Submode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"With Extend + Delete Menu"}),": Extend \u2192 Right \u2192 Open Delete Menu \u2192 Right"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Since most deletions involve only one selection, the menu approach is more efficient for the common case while keeping the Delete Submode available for users who prefer chaining deletions."}),"\n",(0,s.jsx)(n.h2,{id:"version-6-momentary-layer",children:"Version 6: Momentary Layer"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://zmk.dev/docs/keymaps/behaviors/layers#momentary-layer",children:"Momentary Layer"})," combines the best aspects of both the Delete Menu and Delete Submode approaches: it's as efficient as the Delete Menu for single deletions while being as repeatable as the Delete Submode for chained operations."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's how it works: when the Delete key (",(0,s.jsx)(n.code,{children:"v"})," at the time of writing) is ",(0,s.jsx)(n.strong,{children:"held down"}),", the Delete submode activates, allowing you to repeatedly press movement keys like Right to delete multiple selections forward. As soon as you release the Delete key, the Delete submode automatically deactivates."]}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.strong,{children:"tapped"})," (pressed and released immediately), it executes the Delete One action directly, making the most common case even more efficient than the Delete Menu, which required two keypresses (i.e. ",(0,s.jsx)(n.code,{children:"v v"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"The momentary layer approach eliminates the keypress overhead of explicitly entering and exiting modes, making deletion feel more natural and immediate."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);